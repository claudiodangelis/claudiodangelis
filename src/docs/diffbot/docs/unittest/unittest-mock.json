{"name":"unittest-mock","qualifiedName":"unittest/unittest-mock","comment":"<p>A simple mocking/spy library.</p>\n<h2>Installing</h2>\n<p>Use <a href=\"http://pub.dartlang.org\">pub</a> to install this package. Add the following to your <code>pubspec.yaml</code>\nfile.</p>\n<pre><code>dependencies:\n  unittest: any\n</code></pre>\n<p>Then run <code>pub install</code>.</p>\n<p>Import this into your Dart code with:</p>\n<pre><code>import 'package:unittest/mock.dart';\n</code></pre>\n<p>For more information, see the <a href=\"http://pub.dartlang.org/packages/unittest\">unittest package on pub.dartlang.org</a>.</p>\n<h2>Using</h2>\n<p>To create a mock objects for some class T, create a new class using:</p>\n<pre><code>class MockT extends Mock implements T {};\n</code></pre>\n<p>Then specify the <a>unittest/unittest-mock.Behavior</a> of the Mock for different methods using\nwhen (to select the method and parameters) and then the <a>unittest/unittest-mock.Action</a>s\nfor the <a>unittest/unittest-mock.Behavior</a> by calling thenReturn, alwaysReturn, thenThrow,\nalwaysThrow, thenCall or alwaysCall.</p>\n<p>thenReturn, thenThrow and thenCall are one-shot so you would\ntypically call these more than once to specify a sequence of actions;\nthis can be done with chained calls, e.g.:</p>\n<pre><code> m.when(callsTo('foo')).\n     thenReturn(0).thenReturn(1).thenReturn(2);\n</code></pre>\n<p>thenCall and alwaysCall allow you to proxy mocked methods, chaining\nto some other implementation. This provides a way to implement 'spies'.</p>\n<p>For getters and setters, use \"get foo\" and \"set foo\"-style arguments\nto <a>unittest/unittest-mock.callsTo</a>.</p>\n<p>You can disable logging for a particular <a>unittest/unittest-mock.Behavior</a> easily:</p>\n<pre><code>m.when(callsTo('bar')).logging = false;\n</code></pre>\n<p>You can then use the mock object. Once you are done, to verify the\nbehavior, use getLogs to extract a relevant subset of method call\nlogs and apply Matchers to these through calling verify.</p>\n<p>A Mock can be given a name when constructed. In this case instead of\nkeeping its own log, it uses a shared log. This can be useful to get an\naudit trail of interleaved behavior. It is the responsibility of the user\nto ensure that mock names, if used, are unique.</p>\n<p>Limitations:</p><ul><li>only positional parameters are supported (up to 10);</li><li>\n<p>to mock getters you will need to include parentheses in the call\n  (e.g. m.length() will work but not m.length).</p></li></ul>\n<p>Here is a simple example:</p>\n<pre><code>class MockList extends Mock implements List {};\n\nList m = new MockList();\nm.when(callsTo('add', anything)).alwaysReturn(0);\n\nm.add('foo');\nm.add('bar');\n\ngetLogs(m, callsTo('add', anything)).verify(happenedExactly(2));\ngetLogs(m, callsTo('add', 'foo')).verify(happenedOnce);\ngetLogs(m, callsTo('add', 'isNull)).verify(neverHappened);\n</code></pre>\n<p>Note that we don't need to provide argument matchers for all arguments,\nbut we do need to provide arguments for all matchers. So this is allowed:</p>\n<pre><code>m.when(callsTo('add')).alwaysReturn(0);\nm.add(1, 2);\n</code></pre>\n<p>But this is not allowed and will throw an exception:</p>\n<pre><code>m.when(callsTo('add', anything, anything)).alwaysReturn(0);\nm.add(1);\n</code></pre>\n<p>Here is a way to implement a 'spy', which is where we log the call\nbut then hand it off to some other function, which is the same\nmethod in a real instance of the class being mocked:</p>\n<pre><code>class Foo {\n  bar(a, b, c) =&gt; a + b + c;\n}\n\nclass MockFoo extends Mock implements Foo {\n  Foo real;\n  MockFoo() {\n    real = new Foo();\n    this.when(callsTo('bar')).alwaysCall(real.bar);\n  }\n}\n</code></pre>\n<p>However, there is an even easier way, by calling <a>unittest/unittest-mock.Mock.Mock-spy</a>, e.g.:</p>\n<pre><code> var foo = new Foo();\n var spy = new Mock.spy(foo);\n print(spy.bar(1, 2, 3));\n</code></pre>\n<p>Spys created with Mock.spy do not have user-defined behavior;\nthey are simply proxies,  and thus will throw an exception if\nyou call when. They capture all calls in the log, so you can\ndo assertions on their history, such as:</p>\n<pre><code>  spy.getLogs(callsTo('bar')).verify(happenedOnce);\n</code></pre>","variables":{"sharedLog":{"name":"sharedLog","qualifiedName":"unittest/unittest-mock.sharedLog","comment":"<p>The shared log used for named mocks.</p>","final":"false","static":"false","constant":"false","type":[{"outer":"unittest/unittest-mock.LogEntryList","inner":[]}],"annotations":[]},"happenedAtMostOnce":{"name":"happenedAtMostOnce","qualifiedName":"unittest/unittest-mock.happenedAtMostOnce","comment":"<p><a>unittest/unittest-mock.happenedAtMostOnce</a> matches zero or one call.</p>","final":"false","static":"false","constant":"true","type":[{"outer":"unittest/unittest-matcher.Matcher","inner":[]}],"annotations":[]},"happenedAtLeastOnce":{"name":"happenedAtLeastOnce","qualifiedName":"unittest/unittest-mock.happenedAtLeastOnce","comment":"<p><a>unittest/unittest-mock.happenedAtLeastOnce</a> matches one or more calls.</p>","final":"false","static":"false","constant":"true","type":[{"outer":"unittest/unittest-matcher.Matcher","inner":[]}],"annotations":[]},"happenedOnce":{"name":"happenedOnce","qualifiedName":"unittest/unittest-mock.happenedOnce","comment":"<p><a>unittest/unittest-mock.happenedOnce</a> matches exactly one call.</p>","final":"false","static":"false","constant":"true","type":[{"outer":"unittest/unittest-matcher.Matcher","inner":[]}],"annotations":[]},"neverHappened":{"name":"neverHappened","qualifiedName":"unittest/unittest-mock.neverHappened","comment":"<p><a>unittest/unittest-mock.neverHappened</a> matches zero calls.</p>","final":"false","static":"false","constant":"true","type":[{"outer":"unittest/unittest-matcher.Matcher","inner":[]}],"annotations":[]}},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{"neverThrew":{"name":"neverThrew","qualifiedName":"unittest/unittest-mock.neverThrew","comment":"<p><a>unittest/unittest-mock.neverThrew</a> asserts that no matching call to a method threw\na value that matched <a>unittest/unittest-mock.neverThrew.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":"false","abstract":"false","constant":"false","return":[{"outer":"unittest/unittest-matcher.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":"false","named":"false","default":"false","type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"sometimeThrew":{"name":"sometimeThrew","qualifiedName":"unittest/unittest-mock.sometimeThrew","comment":"<p><a>unittest/unittest-mock.sometimeThrew</a> asserts that at least one matching call to a method threw\na value that matched <a>unittest/unittest-mock.sometimeThrew.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":"false","abstract":"false","constant":"false","return":[{"outer":"unittest/unittest-matcher.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":"false","named":"false","default":"false","type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"alwaysThrew":{"name":"alwaysThrew","qualifiedName":"unittest/unittest-mock.alwaysThrew","comment":"<p><a>unittest/unittest-mock.alwaysThrew</a> asserts that all matching calls to a method threw\na value that matched <a>unittest/unittest-mock.alwaysThrew.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":"false","abstract":"false","constant":"false","return":[{"outer":"unittest/unittest-matcher.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":"false","named":"false","default":"false","type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"neverReturned":{"name":"neverReturned","qualifiedName":"unittest/unittest-mock.neverReturned","comment":"<p><a>unittest/unittest-mock.neverReturned</a> asserts that no matching calls to a method returned\na value that matched <a>unittest/unittest-mock.neverReturned.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":"false","abstract":"false","constant":"false","return":[{"outer":"unittest/unittest-matcher.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":"false","named":"false","default":"false","type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"sometimeReturned":{"name":"sometimeReturned","qualifiedName":"unittest/unittest-mock.sometimeReturned","comment":"<p><a>unittest/unittest-mock.sometimeReturned</a> asserts that at least one matching call to a method\nreturned a value that matched <a>unittest/unittest-mock.sometimeReturned.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":"false","abstract":"false","constant":"false","return":[{"outer":"unittest/unittest-matcher.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":"false","named":"false","default":"false","type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"alwaysReturned":{"name":"alwaysReturned","qualifiedName":"unittest/unittest-mock.alwaysReturned","comment":"<p><a>unittest/unittest-mock.alwaysReturned</a> asserts that all matching calls to a method returned\na value that matched <a>unittest/unittest-mock.alwaysReturned.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":"false","abstract":"false","constant":"false","return":[{"outer":"unittest/unittest-matcher.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":"false","named":"false","default":"false","type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"throwing":{"name":"throwing","qualifiedName":"unittest/unittest-mock.throwing","comment":"<p><a>unittest/unittest-mock.throwing</a> matches log entrues where the call to a method threw\na value that matched <a>unittest/unittest-mock.throwing.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":"false","abstract":"false","constant":"false","return":[{"outer":"unittest/unittest-matcher.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":"false","named":"false","default":"false","type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"returning":{"name":"returning","qualifiedName":"unittest/unittest-mock.returning","comment":"<p><a>unittest/unittest-mock.returning</a> matches log entries where the call to a method returned\na value that matched <a>unittest/unittest-mock.returning.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":"false","abstract":"false","constant":"false","return":[{"outer":"unittest/unittest-matcher.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":"false","named":"false","default":"false","type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"happenedAtMost":{"name":"happenedAtMost","qualifiedName":"unittest/unittest-mock.happenedAtMost","comment":"<p><a>unittest/unittest-mock.happenedAtMost</a> matches a maximum number of calls.</p>","commentFrom":"","inheritedFrom":"","static":"false","abstract":"false","constant":"false","return":[{"outer":"unittest/unittest-matcher.Matcher","inner":[]}],"parameters":{"count":{"name":"count","optional":"false","named":"false","default":"false","type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"happenedAtLeast":{"name":"happenedAtLeast","qualifiedName":"unittest/unittest-mock.happenedAtLeast","comment":"<p><a>unittest/unittest-mock.happenedAtLeast</a> matches a minimum number of calls.</p>","commentFrom":"","inheritedFrom":"","static":"false","abstract":"false","constant":"false","return":[{"outer":"unittest/unittest-matcher.Matcher","inner":[]}],"parameters":{"count":{"name":"count","optional":"false","named":"false","default":"false","type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"happenedExactly":{"name":"happenedExactly","qualifiedName":"unittest/unittest-mock.happenedExactly","comment":"<p><a>unittest/unittest-mock.happenedExactly</a> matches an exact number of calls.</p>","commentFrom":"","inheritedFrom":"","static":"false","abstract":"false","constant":"false","return":[{"outer":"unittest/unittest-matcher.Matcher","inner":[]}],"parameters":{"count":{"name":"count","optional":"false","named":"false","default":"false","type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"callsTo":{"name":"callsTo","qualifiedName":"unittest/unittest-mock.callsTo","comment":"<p>Returns a <a>unittest/unittest-mock.CallMatcher</a> for the specified signature. <a>unittest/unittest-mock.callsTo.method</a> can be\nnull to match anything, or a literal <a>dart-core.String</a>, a predicate <a>dart-core.Function</a>,\nor a <a>unittest/unittest-matcher.Matcher</a>. The various arguments can be scalar values or <a>unittest/unittest-matcher.Matcher</a>s.\nTo match getters and setters, use \"get \" and \"set \" prefixes on the names.\nFor example, for a property \"foo\", you could use \"get foo\" and \"set foo\"\nas literal string arguments to callsTo to match the getter and setter\nof \"foo\".</p>","commentFrom":"","inheritedFrom":"","static":"false","abstract":"false","constant":"false","return":[{"outer":"unittest/unittest-mock.CallMatcher","inner":[]}],"parameters":{"method":{"name":"method","optional":"true","named":"false","default":"false","type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg0":{"name":"arg0","optional":"true","named":"false","default":"true","type":[{"outer":"dynamic","inner":[]}],"value":"ConstructedConstant(_Sentinel())","annotations":[]},"arg1":{"name":"arg1","optional":"true","named":"false","default":"true","type":[{"outer":"dynamic","inner":[]}],"value":"ConstructedConstant(_Sentinel())","annotations":[]},"arg2":{"name":"arg2","optional":"true","named":"false","default":"true","type":[{"outer":"dynamic","inner":[]}],"value":"ConstructedConstant(_Sentinel())","annotations":[]},"arg3":{"name":"arg3","optional":"true","named":"false","default":"true","type":[{"outer":"dynamic","inner":[]}],"value":"ConstructedConstant(_Sentinel())","annotations":[]},"arg4":{"name":"arg4","optional":"true","named":"false","default":"true","type":[{"outer":"dynamic","inner":[]}],"value":"ConstructedConstant(_Sentinel())","annotations":[]},"arg5":{"name":"arg5","optional":"true","named":"false","default":"true","type":[{"outer":"dynamic","inner":[]}],"value":"ConstructedConstant(_Sentinel())","annotations":[]},"arg6":{"name":"arg6","optional":"true","named":"false","default":"true","type":[{"outer":"dynamic","inner":[]}],"value":"ConstructedConstant(_Sentinel())","annotations":[]},"arg7":{"name":"arg7","optional":"true","named":"false","default":"true","type":[{"outer":"dynamic","inner":[]}],"value":"ConstructedConstant(_Sentinel())","annotations":[]},"arg8":{"name":"arg8","optional":"true","named":"false","default":"true","type":[{"outer":"dynamic","inner":[]}],"value":"ConstructedConstant(_Sentinel())","annotations":[]},"arg9":{"name":"arg9","optional":"true","named":"false","default":"true","type":[{"outer":"dynamic","inner":[]}],"value":"ConstructedConstant(_Sentinel())","annotations":[]}},"annotations":[]}}},"classes":{"class":[{"name":"Mock","qualifiedName":"unittest/unittest-mock.Mock","preview":"<p>The base class for all mocked objects.</p>"},{"name":"LogEntryList","qualifiedName":"unittest/unittest-mock.LogEntryList","preview":"<p>We do verification on a list of <a>unittest/unittest-mock.LogEntry</a>s. To allow chaining\nof calls to verify, we encapsulate such a list in the <a>unittest/unittest-mock.LogEntryList</a>\nclass.</p>"},{"name":"LogEntry","qualifiedName":"unittest/unittest-mock.LogEntry","preview":"<p>Every call to a <a>unittest/unittest-mock.Mock</a> object method is logged. The logs are\nkept in instances of <a>unittest/unittest-mock.LogEntry</a>.</p>"},{"name":"Behavior","qualifiedName":"unittest/unittest-mock.Behavior","preview":"<p>A <a>unittest/unittest-mock.Behavior</a> represents how a <a>unittest/unittest-mock.Mock</a> will respond to one particular\ntype of method call.</p>"},{"name":"CallMatcher","qualifiedName":"unittest/unittest-mock.CallMatcher","preview":"<p>A <a>unittest/unittest-mock.CallMatcher</a> is a special matcher used to match method calls (i.e.\na method name and set of arguments). It is not a <a>unittest/unittest-matcher.Matcher</a> like the\nunit test <a>unittest/unittest-matcher.Matcher</a>, but instead represents a method name and a\ncollection of <a>unittest/unittest-matcher.Matcher</a>s, one per argument, that will be applied\nto the parameters to decide if the method call is a match.</p>"},{"name":"Responder","qualifiedName":"unittest/unittest-mock.Responder","preview":"<p>The behavior of a method call in the mock library is specified\nwith <a>unittest/unittest-mock.Responder</a>s. A <a>unittest/unittest-mock.Responder</a> has a <a>unittest/unittest-mock.Responder.value</a> to throw\nor return (depending on the type of <a>unittest/unittest-mock.Responder.action</a>),\nand can either be one-shot, multi-shot, or infinitely repeating,\ndepending on the value of [count (1, greater than 1, or 0 respectively).</p>"},{"name":"Action","qualifiedName":"unittest/unittest-mock.Action","preview":"<p>The ways in which a call to a mock method can be handled.</p>"}],"typedef":{"StepValidator":{"name":"StepValidator","qualifiedName":"unittest/unittest-mock.StepValidator","comment":"<p>[StepValidator]s are used by [stepwiseValidate] in [LogEntryList], which\niterates through the list and call the [StepValidator] function with the\nlog [List] and position. The [StepValidator] should return the number of\npositions to advance upon success, or zero upon failure. When zero is\nreturned an error is reported.</p>","return":"dart-core.int","parameters":{"logs":{"name":"logs","optional":"false","named":"false","default":"false","type":[{"outer":"dart-core.List","inner":[{"outer":"unittest/unittest-mock.LogEntry","inner":[]}]}],"value":"null","annotations":[]},"pos":{"name":"pos","optional":"false","named":"false","default":"false","type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]}},"annotations":[],"generics":{}}},"error":[]},"packageName":"unittest","packageIntro":""}